# 세대별 쓰레기 수집가(Generational Garbage Collector)
# GGC는 "대부분의 객체는 생성되고 오래 살아남지 못하고 곧바로 버려진다, 젊은 객체가 오래된 객체를 참조하는 상황은 드물다"
# 라는 가설을 기반으로 동작한다.

# GGC의 핵심은 세대(Generation)와 임계값(Threshold)이다.
# Python의 GC는 총 3세대(0, 1, 2)이다.
# 각 세대마다 GC 모듈에는 임계값이 있으며,
# 각 세대의 객체 수가 해당 임계값을 초과하면 GC를 실행한다.
# 0세대에서 살아남은 객체는 다음 1세대로 옮겨지고 1세대의 카운트는 1 증가한다.
# 이런 방식으로, 젊은 세대에서 임계값이 초과되면 오래된 세대로 위임하는 방식으로 동작한다.

# Python에서는 참조 횟수 메커니즘(Reference Counting Mechanism)은 변경할 수 없다.
# 대신에, GGC의 동작은 변경할 수 있다.
# 1. GC를 추적하기 위한 임계값 변경
# 2. GC를 수동으로 추적
# 3. GC 비활성화

# GC는 성능에 어떤 영향을 주는가?
# GC를 수행하려면 응용 프로그램을 완전히 중지해야 한다.
# 그러므로, 객체가 많을수록 모든 쓰레기(Garbage)를 수집하는 시간이 오래 걸린다.
# GC의 주기가 짧다면 응용 프로그램이 중지되는 상황이 증가하고
# 반대로, 주기가 길어진다면 메모리 공간에 쓰레기(Garbage)가 많이 쌓일 것이다.

# GC의 장점
# 개발자는 동적으로 할당한 메모리 영역을 관리할 필요가 없다.
# 메모리 누수, 유효하지 않은 포인터 접근의 문제점을 해결할 수 있다.

# GC의 단점
# 어떤 메모리를 해제할지 결정하는데 비용이 든다.
# 객체가 필요 없어지는 시점을 프로그래머가 알고 있어도
# GC 알고리즘이 메모리 해제 시점을 추적해야 한다.
# GC가 일어나는 타이밍이나 점유 시간을 미리 예측하기 어려워 실시간 시스템에는 적합하지 않다.
# 참고로, 인스타그램(Instagram)은 Python의 GC를 사용하지 않는다.)

import gc

# 가비지 컬렉터의 임계값 확인 => gc.get_threshold()
print("\n ====== ====== ====== ====== ======")
print(gc.get_threshold())
# (Threshold 0, Threshold 1, Threshold 2)
# n 세대에 객체를 할당한 횟수가 threshold n을 초과하면
# GC가 수행된다.

# 각 세대의 객체 수 확인 => gc.get_count()
print("\n ====== ====== ====== ====== ======")
print(gc.get_count())
# (가장 어린 세대, 다음 세대, 가장 오래된 세대)

# GC 실행 => gc.collect()
# Python은 프로그램을 시작하기 전에, 기본적으로 많은 객체를 생성한다.
# gc.collect() 메소드를 사용하여 수동으로 GC 프로세스를 추적할 수 있다.
print("\n ====== ====== ====== ====== ======")
print(gc.collect())
print(gc.get_count())

# GC 추적 임계값 변경 => gc.set_threshold()
# 임계값을 증가시키면 GC의 실행 빈도가 줄어든다.
print("\n ====== ====== ====== ====== ======")
print(gc.get_threshold())
gc.set_threshold(1120, 13, 44)
print(gc.get_threshold())

